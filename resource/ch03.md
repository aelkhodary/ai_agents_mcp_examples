⬢ Read ch03.md

  This chapter covers MCP (Model Context Protocol) Clients in depth. Let me break down the key concepts as an expert AI instructor.

  MCP Architecture Overview

  MCP has three main components:
  1. Host Application - Your LLM-powered app (chatbot, IDE like Cursor/Windsurf)
  2. Client - Manages connections to MCP servers
  3. Server - Provides capabilities (tools, resources, prompts)

  Key constraint: A single client can only talk to a single server. For multiple servers, you need multiple client instances.

  The Three MCP Primitives


  | Primitive | Purpose                                                               |
  |-----------|-----------------------------------------------------------------------|
  | Tools     | Executable functions the LLM can call (e.g., calculator, weather API) |
  | Resources | Data access (files, database records, images) for context             |
  | Prompts   | Reusable prompt templates with optional arguments                     |


  Transport Mechanisms

  Two official transport layers:
  1. stdio - For local servers running as subprocesses. Most common for desktop apps.
  2. Streamable HTTP - For remote servers. Supports both immediate HTTP responses and optional SSE streaming.


  Client Design Pattern

  The chapter establishes a consistent pattern for each primitive:

  Discovery → list_<primitive>s() → Get available items
  Usage     → call_tool() / read_resource() / get_prompt()


  Key Implementation Details

  Connection Management: Uses Python's AsyncExitStack to manage nested async contexts, allowing clean connection/disconnection.
  Tool Response Types:
  • TextContent - Text results
  • ImageContent / AudioContent - Base64-encoded media
  • EmbeddedResource - Inline resources for caching

  LLM Integration Flow (for tools):
  1. Get available tools from server
  2. Pass tools to LLM with user query
  3. If LLM returns stop_reason == "tool_use", execute the tool
  4. Return results to LLM for final response


  Security Considerations

  • Never commit .env files with API keys
  • Remote transports (Streamable HTTP) need authentication and origin validation
  • Roots define boundaries servers should respect (but aren't enforced)


  Performance Warning

  Tool-calling performance degrades as more tools are added due to selection difficulty and description overlap. Keep tool sets focused.
  This chapter essentially teaches you how to build an MCP-enabled chatbot that can discover and use server-provided capabilities
  dynamically.